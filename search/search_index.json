{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#intelligent-tutoring-system-its-for-programming-education","title":"Intelligent Tutoring System (ITS) for Programming Education","text":"Figure 1: General idea of an ITS that supports students and tutors in programming courses."},{"location":"index.html#motivation","title":"Motivation","text":"<p>In Computer Science (CS) education, we face the challenge of increasing student enrollments over the past few years. Consequently, it has become increasingly difficult to provide high-quality and individualized learning support, particularly for novice students. Mirhosseini et al. recently conducted an interview study with CS instructors to identify their biggest pain points. Among other issues, they found that CS instructors struggle with limited or no Teaching Assistant (TA) support and the generally time-consuming task of providing student feedback and grading assignments. Thus, CS instructors would greatly benefit from automating tutoring activities to support TAs in their responsibilities.</p>"},{"location":"index.html#development","title":"Development","text":"<p>Intelligent Tutoring System (ITS) for Programming Education is a fully automated tutoring system developed at the Trustworthy and Secure Software Lab of the National University of Singapore (NUS) that aims to provide on-time personalized feedback to students and grading support to tutors/instructors for programming assignments in Computer Science (CS) courses. It is a language-independent system that can be used with any programming language (e.g., Python, Java, C, etc.). It supports various functionalities, including syntax error fixing, logical error localization / repairing, and programming conceptual automated grading. Notably, the ITS is tightly coupled with the advanced large language models (LLMs) to provide high-level natural language feedback to students. The ITS has been used in CS1010S and CS2040S at NUS.</p>"},{"location":"index.html#general-idea","title":"General Idea","text":"<p>Figure 1 illustrates the general concept of the Intelligent Tutoring System. The lecturer provides reference programs and test cases as specifications of a programming assignment, and students submit their solutions to the ITS. The ITS then automatically fixes the student\u2019s code if it is incorrect and elaborates on the fixes to provide high-level feedback as hints, gradually guiding the student to understand the foundational reason for the error. Additionally, the ITS provides a grading support system that automatically grades student submissions for lecturers.</p> <p>This website provides detailed documentation of the ITS, including</p> <ul> <li>Demo Usage</li> <li>API Documentation</li> <li>Overview of the system architecture</li> <li>Detailed features of the system</li> <li>Illustration of the system components.</li> </ul>"},{"location":"index.html#experience-in-practice","title":"Experience in Practice","text":"<p>We share our experience in building and using the ITS in the following CS courses at NUS:</p> <ul> <li>CS3213 Foundations of Software Engineering: Building the ITS along with Software Engineering teaching.</li> <li>CS1010S Programming Methodology: Experience of ITS in CS-1 course.</li> <li>CS2040S Data Structures and Algorithms: Experience of ITS in CS-2 course.</li> </ul> <p>This documentation is intended for students, lecturers, and developers who are interested in using the ITS for their programming courses. Please reach out if you are interested in collaborating with us or have any questions about the system.</p>"},{"location":"ack.html","title":"Acknowledgement","text":"<p>We thank for all contributors who have contributed to implement the Intelligent Tutoring System, including,</p> <p>FYP Students in Academic Year 2021 -- 2022</p> <p>Kishore R Ai Guo Jon Chua</p> <p>FYP Students in Academic Year 2022 -- 2023</p> <p>Christopher Goh Huang Zhenxin Eris Jacey Masagaca Ethan Noah Rozario</p> <p>All CS3213 Students in Academic Year 2021 -- 2023</p> <p>We thank for relevant research that makes Intelligent Tutoring System become a reality.</p> <p>Verifix: Verified repair of programming assignments Automated Clustering and Program Repair for Introductory Programming Assignments Search, Align, and Repair: Data-Driven Feedback Generation for Introductory Programming Exercises Refactory: Re-factoring based Program Repair applied to Programming Assignments Concept-based Automated Grading of CS-1 Programming Assignments</p> <p>We thank for the funding supported by a Singapore Ministry of Education (MoE) Tier 3 grant \"Automated Program Repair\", MOE-MOET32021-0001.</p>"},{"location":"contact.html","title":"Contact Us","text":"Abhik Roychoudhury Provost\u2019s Chair Professor, NUS <p>Abhik Roychoudhury is a Provost's Chair Professor of Computer Science at the National University of Singapore. Prof Abhik's research focuses on software testing and analysis, software security and trust-worthy software construction. His research on automatically repairing programs at a large scale contributes to the vision of self-healing software. His research team is known for contributions to program repair, and fuzz testing.</p> Zhiyu Fan PhD Candidate, NUS <p>Zhiyu Fan is a final year PhD candidate in the School of Computing at the National University of Singapore, advised by Prof. Abhik Roychoudhury. He is broadly interest in Software Engineering and Generative AI, his research has been focused on the intersections of automated program repair, automatic programming, and computer science education. His has led the development of Intelligent Tutoring System to boost Computer Science education at scale via SE and LLM techniques, which has been deployed in NUS.</p> <p>If you are a researcher or teaching staff at a university and are interested in adopting our resources for your teaching purpose, please get in touch with abhik@comp.nus.edu.sg, zhiyufan@outlook.com.</p>"},{"location":"ip.html","title":"Intellectual Property","text":"<p>The Intelligent Tutoring System is registered under the license of National University of Singapore</p> <p>Please refer to https://tech.nus.edu.sg/product/231</p>"},{"location":"courses/cs1010s/intro.html","title":"Introduction","text":"<p>This section describes how Intelligent Tutoring System is being deployed the first-year programming course CS1010S Programming Methodology in NUS School of Computing.</p>"},{"location":"courses/cs1010s/intro.html#teaching-platform","title":"Teaching Platform","text":""},{"location":"courses/cs1010s/intro.html#web-browser-plugin","title":"Web Browser Plugin","text":""},{"location":"courses/cs1010s/intro.html#discord-group-teaching-bot","title":"Discord Group Teaching Bot","text":""},{"location":"courses/cs3213/intro.html","title":"CS3213 Foundations of Software Engineering","text":""},{"location":"courses/cs3213/intro.html#challenges-motivation","title":"Challenges &amp; Motivation","text":"<p>One typical problem in CS education is the provision of Software Engineering (SE) projects. Software engineering is typically a compulsory course in the university's curriculum for computer science students, and it is often followed or accompanied by development projects, in which students can collect hands-on experience in software development in a team going beyond a programming exercise. Such projects come with inherent difficulties like acquiring industry partners and the dilemma that such software projects are often under- or over-specified. Additionally, such projects are often one-time efforts within one team or one course, and students cannot experience the evolution of a software system.</p> <p>Foundations of Software Engineering (CS3213) is the foundations of the entire Intelligent Tutoring System. </p> Figure 1: Illustration of Developing ITS with CS3213 <p>This course will provide the students with foundational knowledge and understanding of different aspects of software engineering including requirements, modelling, architecture, behavior, environment, software analysis, validation and verification. It will serve as a second software engineering course exposing the students to the mathematical foundations of software engineering while simultaneously supplementing and elaborating the foundations in the form of a semester long project.</p>"},{"location":"courses/cs3213/intro.html#long-running-software-engineering-project","title":"Long-running Software Engineering Project","text":""},{"location":"courses/cs3213/intro.html#short-running-software-engineering-project","title":"Short-running Software Engineering Project","text":""},{"location":"courses/cs3213/intro.html#curriculum","title":"Curriculum","text":""},{"location":"courses/cs3213/lecture.html","title":"CS3213 Lecture Material","text":""},{"location":"courses/cs3213/lecture.html#lecture-1-introduction","title":"Lecture 1: Introduction","text":"<p>slides 1, slides 2, recording</p> <p>In this lecture, we introduced the foundations and the project in this course. Additionally, we introduced the field of \"requirements engineering\".</p>"},{"location":"courses/cs3213/lecture.html#lecture-2-uml","title":"Lecture 2: UML","text":"<p>slides, recording (part 1), recording (part 2) </p> <p>In this lecture, we discussed UML semantics, including sequence diagram based formal modeling of the system description beyond scenarios.</p>"},{"location":"courses/cs3213/lecture.html#lecture-3-state-charts","title":"Lecture 3: State Charts","text":"<p>slides, recording</p> <p>In this lecture, we described the nuances of state chart semantics.</p>"},{"location":"courses/cs3213/lecture.html#lecture-4-intelligent-tutoring-system","title":"Lecture 4: Intelligent Tutoring System","text":"<p>slides, recording (part 1), recording (part 2), recording (part 2)</p> <p>In this lecture, we gave an idea of the area behind the course project - Intelligent tutoring systems. We discussed the general topic, available tools, involved technical challenges, and the feedback issue in intelligent tutoring.</p>"},{"location":"courses/cs3213/lecture.html#lecture-5-static-analysis-part-1-motivation","title":"Lecture 5: Static Analysis (Part 1 Motivation)","text":"<p>slides, recording </p> <p>In this lecture, we discussed program representations such as the Control Flow Graph (CFG).</p>"},{"location":"courses/cs3213/lecture.html#lecture-6-static-analysis-part-2-program-representation","title":"Lecture 6: Static Analysis (Part 2 Program Representation)","text":"<p>slides, recording</p> <p>In this lecture, we covered simpler descriptin of static program analysis based on data-flow analysis.</p>"},{"location":"courses/cs3213/lecture.html#lecture-7-white-box-testing-test-suite-estimation","title":"Lecture 7: White-box Testing / Test suite estimation","text":"<p>slides, recording </p> <p>In this lecture, we discussed white box testing and test-suite estimation.</p>"},{"location":"courses/cs3213/lecture.html#lecture-8-mid-term","title":"Lecture 8: Mid-term","text":""},{"location":"courses/cs3213/lecture.html#lecture-9-debugging","title":"Lecture 9: Debugging","text":"<p>slides, recording</p> <p>In this lecture, we continued with our discussions on testing and analysis. Some background material on software debugging was presented, including slicing and fault localisation.</p>"},{"location":"courses/cs3213/lecture.html#lecture-10-non-functional-issues-security-and-timeliness","title":"Lecture 10: Non-functional issues: Security and Timeliness","text":"<p>slides 1, slides 2, recording </p> <p>In this lecture, we discussed software performance issues and timing-critical software design.</p>"},{"location":"courses/cs3213/lecture.html#lecture-11-invitation-talks","title":"Lecture 11: Invitation Talks","text":"<p>slides</p> <p>In this lecture, we had two talks on emerging research topics in automated programming by Dr. Sumit Gulwani and Professor Ilya Sergey.</p>"},{"location":"courses/cs3213/lecture.html#lecture-12-revision-of-topics","title":"Lecture 12: Revision of topics","text":"<p>slides, recording</p> <p>In this lecture, we first continued our discussion on sofware performance aspects, and then recapped previous course topics with some warm-up exercises.</p>"},{"location":"courses/cs3213/lecture_p.html","title":"CS3213 Lecture (Project Part)","text":""},{"location":"courses/cs3213/lecture_p.html#lecture-1-introduction-to-course-project","title":"Lecture 1: Introduction to Course Project","text":"<p>slides</p> <p>In Lecture 1, we introduced the idea and topic of our course projects and explained the logistics of our lab session. Furthermore, we introduced the basics of requirements and their elicitation, as needed for Lecture 2.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-2-requirements-elicitation","title":"Lecture 2: Requirements Elicitation","text":"<p>slides</p> <p>In Lecture 2, we performed a live requirements elicitation section with real stakeholders of our overall project. The students prepared questions in advance and interviewed the customers.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-3-requirements-modeling","title":"Lecture 3: Requirements Modeling","text":"<p>slides</p> <p>In Lecture 3, we discussed the requirements elicitation session performed in Lecture 2 and further discussed the resulting requirements models submitted by the students. We provided a general introduction to software architecture to set foot in the solution space.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-4-architecture","title":"Lecture 4: Architecture","text":"<p>slides</p> <p>In Lecture 4, we provided more information on the existing architecture of our project's framework and illustrated several architectural styles.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-5-design-planning","title":"Lecture 5: Design Planning","text":"<p>slides</p> <p>In Lecture 5, we discussed aspects of the module design for each project and introduced essential parts of our baseline implementation as the internal program representation. We further discussed the basics of project planning.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-6-testing","title":"Lecture 6: Testing","text":"<p>slides</p> <p>In Lecture 6, we discussed the basics of software testing and introduced concepts like equivalence class partitioning and unit testing.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-7-advanced-testing","title":"Lecture 7: Advanced Testing","text":"<p>slides</p> <p>In Lecture 7, we intensified the knowledge from Lecture 6 about software testing. We discussed aspects of testable code and test-driven development. We further started introducing the foundations of debugging.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-8-debugging","title":"Lecture 8: Debugging","text":"<p>slides</p> <p>In Lecture 8, we investigated more debugging approaches and introduced concepts like TRAFFIC, dynamic and static slicing, and statistical fault localization.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-9-static-analysis","title":"Lecture 9: Static Analysis","text":"<p>slides</p> <p>In Lecture 9, we provided more examples for program slicing and gave a practical introduction to static analysis.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-10-implementation","title":"Lecture 10: Implementation","text":"<p>slides</p> <p>In Lecture 10, we discussed implementation aspects and introduced several notions of clean code.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-11-integration","title":"Lecture 11: Integration","text":"<p>slides</p> <p>In Lecture 11, we discussed typical problems with software integration and introduced integration strategies and testing concepts.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-12-summary","title":"Lecture 12: Summary","text":"<p>slides</p> <p>In Lecture 12, we recaped all discussed topics and provided a summary for all project-parts of the lecture.</p>"},{"location":"courses/cs3213/lecture_p.html#lecture-13-final-project-presentations","title":"Lecture 13: Final Project Presentations","text":"<p>slides</p> <p>In Lecture 13, every student group presented their final outcome and demonstrated their contributions.</p>"},{"location":"courses/cs3213/project/intro.html","title":"Overview","text":""},{"location":"courses/cs3213/project/intro.html#intelligent-tutoring-system","title":"Intelligent Tutoring System","text":"<p>The high-level idea of the Intelligent Tutoring System is to introduce an automated technique to provide feedback and grading suggestions for programming assignments. As shown in the above figure, for a given programming assignment, the tutor would provide a reference solution and some test cases, while the student would submit a solution and receive feedback. The feedback should go beyond the simple execution of test cases and tell the student where and how to fix the submission. More sophisticated and gradual ways of feedback could also be introduced.</p>"},{"location":"courses/cs3213/project/topics.html","title":"Topics","text":"<p>Developing such an Intelligent Tutoring System (ITS) includes many conceptual and technical challenges. We summarized some of them into projects, from which the students in CS3213 need to choose one as a group project. Please find below the project summaries as proposed for the students in CS3213 (NUS AY 2021/2022). We group projects by their provided functionalities. Each project has assigned estimated difficulty levels (Low, Medium, High) in the categories: coding (i.e., programming intensity), theoretical complexity (i.e., need for background study), amount of research involved (i.e., be innovative and create something new), and the involvement of HCI (Human-Computer Interaction) aspects.</p> <p>More details can be found in our Assignment 0.</p>"},{"location":"courses/cs3213/project/topics.html#topic-1-parsing","title":"Topic 1 - Parsing","text":"<p>Project 1.1 C Parser: Develop a parser to transform C programs into a (provided) common data structure based on the control-flow graph (CFG). Additionally, provide a concretizer, which back-transforms the program in the internal common data structure to a C source file. \u2192 [Coding: High, Theory: Low, Research: -, HCI: -]</p> <p>Project 1.2 Python Parser: Same as 1.1 for Python. \u2192 [Coding: High, Theory: Low, Research: -, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-2-aligning-matching-of-programs","title":"Topic 2 \u2013 Aligning / Matching of Programs","text":"<p>Project 2.1 CFG-Based Alignment: Develop an automated alignment of the reference program and the submitted program based on the basic blocks of the programs\u2019 control-flow graph (CFG) representation. This also includes the development of an automated mapping for the variables between the reference program and the submitted program. \u2192 [Coding: Medium, Theory: Medium, Research: Low, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-3-error-localization-program-interpretation","title":"Topic 3 \u2013 Error Localization / Program Interpretation","text":"<p>Project 3.1 C Interpreter:  Develop an interpreter that allows to execute a C program with regard to the basic blocks in its CFG. Further, use the provided test cases to identify the root cause of the problem with regard to the basic blocks in the CFG. Implement an error localization that compares the execution traces of a reference program and the submitted program. \u2192 [Coding: High, Theory: Medium, Research: -, HCI: -]</p> <p>Project 3.2 Python Interpreter: same as 3.1 for Python \u2192 [Coding: High, Theory: Medium, Research: -, HCI: -]</p> <p>Project 3.3 Error Localizer: Conduct a literature study on error localization. Develop at least two error localization algorithms from different domains (e.g., statistical fault localization and analysis-based fault localization) for the provided framework and evaluate their efficacy.  \u2192 [Coding: Medium, Theory: High, Research: Low, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-4-transforming-repairing-programs","title":"Topic 4 \u2013 Transforming / Repairing Programs","text":"<p>Project 4.1 Refactoring-based Repair: Develop a repair workflow that first generates semantic-preserving refactorings of a reference program so that it increases the chances of a structural alignment with a submitted program (see Project 2.1). Afterwards, it uses a matching refactoring to repair the submitted program by mutating program expressions. Strive for a minimal repair which satisfies the failing test case(s). \u2192 [Coding: Medium, Theory: Medium, Research: Medium, HCI: -]</p> <p>Project 4.2 Optimization-based Repair: Develop a repair algorithm that (1) generates local repairs at each basic block by matching the submission and the reference solution, and (2) determines the complete repair (i.e., a subset of local repairs) by using some optimization strategy, which minimizes the overall repair cost. \u2192 [Coding: Medium-High, Theory: High, Research: Low, HCI: -]</p> <p>Project 4.3 Synthesis-based Repair: Develop a repair algorithm that searches for a repair by synthesizing program expressions. The synthesis will be driven by the available components at the specific source location. It requires a specification inference, which results in a repair constraint. \u2192 [Coding: Medium, Theory: High, Research: Medium, HCI: -]</p>"},{"location":"courses/cs3213/project/topics.html#topic-5-feedback-generation","title":"Topic 5 \u2013 Feedback Generation","text":"<p>Project 5.1 Automated Feedback: Develop a feedback mechanism to summarize all obtained results in an appropriate and comprehensible manner for the user. For example, show root causes of the problems and provide explanation by annotating the code. \u2192 [Coding: Low, Theory: Medium, Research: Medium, HCI: High]</p> <p>Project 5.2 Automated Grading: Develop a automated grading mechanism, which is beyond simple output of passing and failing test cases, e.g., it should take into account the necessary effort for fixing the submitted program. \u2192 [Coding: Low, Theory: High, Research: High, HCI: Low]</p>"},{"location":"courses/cs3213/project/workflow.html","title":"Workflow","text":"<p>The following steps show the intended workflow through the Intelligent Tutoring System (ITS). Note that there are points of variation (static and dynamic) that depend, e.g., on the programming language of the programming assignments and the intended repair strategies. Many of the current components can be implemented in many different ways.</p>"},{"location":"courses/cs3213/project/workflow.html#overview","title":"Overview","text":"<p>The Intelligent Tutoring System (ITS) uses the notion of a pipes-and-filter style to process the submitted program and, finally, to produce feedback for the students and a grading report for the tutor.</p> <p>All components provide corresponding interfaces to the extent that most components can be implemented independently from each other.</p> <p>This architecture also allows us to deploy specific system components as separate services. In this regard, the design borrows concepts from the service-oriented style. For example, we provide students with access to a Parser service that allows them to easily generate the internal CFG-based Program representation to create test cases for their projects.</p>"},{"location":"courses/cs3213/project/workflow.html#step-1-parser","title":"Step 1: Parser","text":""},{"location":"courses/cs3213/project/workflow.html#step-2-syntactic-alignment","title":"Step 2: Syntactic Alignment","text":""},{"location":"courses/cs3213/project/workflow.html#step-3-error-localizer","title":"Step 3: Error Localizer","text":""},{"location":"courses/cs3213/project/workflow.html#step-4-interpreter","title":"Step 4: Interpreter","text":""},{"location":"courses/cs3213/project/workflow.html#step-5-repair","title":"Step 5: Repair","text":""},{"location":"courses/cs3213/project/workflow.html#step-6-feedback","title":"Step 6: Feedback","text":""},{"location":"courses/cs3213/project/workflow.html#step-7-concretization","title":"Step 7: Concretization","text":""},{"location":"courses/cs3213/project/workflow.html#step-8-auto-grading","title":"Step 8: Auto-Grading","text":""},{"location":"documentation/components.html","title":"Components in Intelligent Tutoring System","text":""},{"location":"documentation/components.html#language-parser","title":"Language Parser","text":"<p>To support multiple programming languages, we designed an internal intermediate program representation capable of expressing the majority of first-year-level syntax and semantics, such as variable declarations, control structures, and basic data types. This intermediate representation ensures that the core functionalities of the ITS can operate independently of the programming language used. For example, it enables lightweight program analyses, such as control flow, variable usage, and data dependency analysis. As the first step in the workflow, the ITS runs a grammar checker to identify the programming language of the current feedback request. Next, the parser component processes the source code of both the reference program and the student\u2019s submission. It invokes the corresponding language-specific parser to generate the intermediate representation of the programs. This representation standardizes the code into a common format used by other components, which allows the ITS to function consistently across different languages. Currently, the parser component includes specific parsers for C, Java, and Python.</p>"},{"location":"documentation/components.html#alignment","title":"Alignment","text":"<p>One key difference between general program repair for large software and program repair for educational purposes is the availability of an expected program specification in the form of a reference implementation. The alignment component is designed to align the reference program with the student\u2019s submission. It processes the intermediate representations of both the reference and student programs to identify matching basic blocks and map the existing variables for each function within the programs. The alignment algorithms are based on the similarity of control flow and variable usage, specifically using Def-Use Analysis, to compare the reference and student programs. The results of this alignment can then be used to pinpoint the locations where the reference and submitted programs diverge in behavior. Furthermore, this information is instrumental in attempting to repair the submitted program by leveraging the data from the reference program. Note that, the ITS takes in multiple reference solutions with different solving strategies as input which increases the alignment success rate like existing APR tools.</p>"},{"location":"documentation/components.html#error-localizer-and-interpreter","title":"Error Localizer and Interpreter","text":"<p>Error localization is a crucial step in APR systems that aims to identify the buggy locations within the software. In the context of computer programming education, error localization identifies specific basic blocks or expressions that violate the expected specifications. The error localizer component employs several dynamic execution-enabled localization algorithms to trigger erroneous behavior in the student\u2019s program. These algorithms include trace-based localization and statistical fault localization. The dynamic program execution is facilitated by an interpreter component. This interpreter allows the execution of a program in its intermediate CFG-based representation without the need for compilation or execution on the actual system. It generates an execution trace with the sequence of executed basic blocks and a memory object, which holds the variable values at specific locations. The error localizer component utilizes the interpreter to execute test cases while observing the variable values at specific locations. This process enables the system to detect semantic differences between the reference and submitted programs, thereby pinpointing the precise locations of errors.</p>"},{"location":"documentation/components.html#repair-engines","title":"Repair Engines","text":"<p>Given the reference programs, student submissions, and the identified error locations as input, the repair component attempts to fix the submitted programs by generating edits that transform the student\u2019s program to be semantically equivalent to the reference program. The repair component acts as an engine that can utilize various repair strategies, such as optimization-based repair, synthesis-based repair, and LLM-based repair. Upon receiving a repair request from the previous components, these repair strategies are invoked in parallel to search for potential repair candidates. The repair engine then selects the optimal repair candidate that minimally alters the student\u2019s submission. This approach aims to guide students in correcting their mistakes while preserving their original intentions as much as possible. Note that, the repair candidate is represented at the level of the intermediate representation of the program, and we convert it back to the source code before proceeding to the feedback generation phase.</p>"},{"location":"documentation/components.html#feedback-generators","title":"Feedback Generators","text":"<p>With the collected information from previous components, the feedback component generates natural language explanations to guide students in correcting their mistakes without revealing the direct answer. This component incorporates a common front-end prompt interface with various LLM backends, allowing flexible switching between different LLMs and easy integration of new LLMs. Currently, it supports both commercial LLMs like GPT and Claude series, as well as open-source LLMs like LLaMA from Meta. We use GPT-3.5 as the default LLM backend to balance performance and cost.</p>"},{"location":"documentation/components.html#automated-grader","title":"Automated Grader","text":"<p>Test-suite based automated grading suffers from the problem that a small mistake by the student can cause many test cases to fail. To provide better support for tutors, we integrate an auto-grading capability in the ITS, which aims to test the conceptual understanding of the student and awards grades accordingly. This is achieved by constructing a concept graph from the student's attempt and comparing it with the concept graph of the instructor's reference solution. The aim is to automatically determine which of the ingredient concepts being tested by the programming assignment are correctly understood by the student. Given the instructor-provided reference solutions and students' incorrect solutions, we apply the abstraction rules to convert students' concrete implementation to conceptual understandings and compare them against the conceptual requirements in reference solutions. Based on the result, the grading component generates a grading report for the tutor. It assesses the student's submission by their missing or improperly used programming concepts to address the over-penalty issue in the conventional test-based assessment.</p>"},{"location":"documentation/overview.html","title":"Overview","text":"Figure 1: Overview of the workflow of the Intelligent Tutoring System."},{"location":"documentation/overview.html#features","title":"Features","text":""},{"location":"getting-started/usage.html","title":"Demo Usage","text":""},{"location":"getting-started/usage.html#example-programming-assignment","title":"Example Programming Assignment","text":"<p>Let's consider a simple programming assignment where students are asked to write a C program that calculates the sum of the first <code>n</code> natural numbers. The program should take an integer <code>n</code> as input and output the sum of the first <code>n</code> natural numbers. </p> <p>The student made a mistake in the inner loop condition at line 8.  The correct loop condition should be <code>j&lt;=i</code> instead of <code>j&lt;=N</code>.</p> <pre><code>#Reference Solution from Instructor \n#include &lt;stdio.h&gt;\nint main(){\n  int i,j,n,sum=0;\n  scanf(\"%d\",&amp;n);  \n  for(i=1;i&lt;=n;i++){\n    for(j=1;j&lt;=i;j++){\n      sum+=j;\n    }\n  }\n  printf(\"%d\",sum);\n  return 0;\n}    \n</code></pre> <pre><code>#Example Student Submission (Incorrect)\n#include &lt;stdio.h&gt;\nint main(){\n  int i,j,N,sum;\n  sum=0;\n  scanf(\"%d\",&amp;N);\n  for(i=1;i&lt;=N;i++){\n    for(j=1;j&lt;=N;j++){ &lt;== Incorrect loop condition\n      sum=sum+j;\n    }\n  }\n  printf(\"%d\",sum);\n  return 0;\n} \n</code></pre>"}]}